---
title: 'ì†Œì…œ ë¡œê·¸ì¸ ê¸°ëŠ¥ ì¶”ê°€(êµ¬ê¸€)'
authors: [jake]
tags: [python, fastapi, oauth2, social, login]
---

## â­ í‚¤ì›Œë“œ

| í‚¤ì›Œë“œ | ì„¤ëª… |
| --- | --- |
| ì†Œì…œ ë¡œê·¸ì¸ | ì†Œì…œë¡œë¶€í„° ë°ì´í„°ë¥¼ ë°›ì•„ì™€ ìì²´ ì‚¬ìš©ì ìƒì„± ë“± |

## ğŸ¥ ì˜ˆì‹œ(Oauth í†µí•© base íŒŒì¼)

```python
from abc import abstractmethod, ABCMeta

from authlib.integrations.starlette_client import OAuth
from sqlalchemy.orm import Session
from starlette.requests import Request

from conf.settings.prod import settings

# Oauth ìƒì„±
from core.choices import SocialTypeChoices

oauth = OAuth()
oauth.register(
    name='google',
    client_id=settings.SOCIAL_ACCOUNT_GOOGLE_CLIENT_ID,
    client_secret=settings.SOCIAL_ACCOUNT_GOOGLE_SECRET,
    server_metadata_url=settings.SOCIAL_ACCOUNT_GOOGLE_CONF_URL,
    client_kwargs={
        'scope': 'openid email profile'
    }
)

class SocialBase:
    def __init__(self, social_type: str = SocialTypeChoices.G.value):
        self.social_type = social_type
        self.oauth = oauth.create_client(self.social_type)

class SocialLogin(SocialBase):
    @property
    def get_redirect_uri(self):
        """
        ë¦¬ë‹¤ì´ë ‰íŠ¸ ì£¼ì†Œ ì¡°íšŒ
        """
        if self.social_type == SocialTypeChoices.G.value:
            return '/v1/auth/account/google/login/callback'

    def authorize_redirect(self, request: Request):
        """
        ë¦¬ë‹¤ì´ë ‰íŠ¸
        """
        client_host = request.headers.get('host')
        redirect_uri = f'http://{client_host}{self.get_redirect_uri}'
        return self.oauth.authorize_redirect(request, redirect_uri)

class SocialCallBack(SocialBase):
    @property
    def get_call_back_class(self):
        """
        ì½œë°± í´ë˜ìŠ¤ ì¡°íšŒ
        """
        social_class = None
        if self.social_type == SocialTypeChoices.G.value:
            from apps.backend.auth.account.controllers.google import SocialCallBackGoogle
            social_class = SocialCallBackGoogle
        return social_class

class SocialCallBackBase(SocialBase, metaclass=ABCMeta):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.validated_data = None
        self.model = None
        self.db = None

    @abstractmethod
    def is_valid(self, user: dict):
        pass

    @abstractmethod
    def save(self):
        pass

    @abstractmethod
    def get_or_create_user(self, request: Request, db: Session):
        pass
```

## ğŸ¥ ì˜ˆì‹œ(google íŒŒì¼)

```python
from authlib.integrations.base_client import OAuthError
from sqlalchemy.orm import Session
from starlette.requests import Request

from apps.backend.auth.account.controllers.base import SocialCallBackBase

class SocialCallBackGoogle(SocialCallBackBase):
    def get_user_or_none(self, email: str):
        assert self.db, 'ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •ì´ ì •ìƒì ìœ¼ë¡œ ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.'

        from apps.backend.auth.user.models import User
        user = self.db.query(User).filter_by(email=email).first()
        return user

    def is_valid(self, user: dict):
        """
        ìœ íš¨ì„± ê²€ì‚¬
        """
				# ìœ íš¨ì„± ê²€ì‚¬
        ...

    def save(self):
        """
        ì €ì¥
        """
        assert self.db, 'ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •ì´ ì •ìƒì ìœ¼ë¡œ ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.'
        assert self.validated_data, 'ìœ íš¨ì„± ê²€ì‚¬ í›„ì— ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.'

				# ë°ì´í„° ì €ì¥
				...
        return user

    async def get_or_create_user(self, request: Request, db: Session):
        try:
            token = await self.oauth.authorize_access_token(request)
        except OAuthError as err:
            from core import exceptions as ex
            raise ex.AuthExceptions.SocialLoginError
        # ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
        self.db = db
        # ì†Œì…œ ì •ë³´ ì¡°íšŒ
        social_user = await self.oauth.userinfo(token=token)
        email = dict(social_user).get('email')
        user = self.get_user_or_none(email)
        if user is None:
            self.is_valid(social_user)
            user = self.save()
        return user
```