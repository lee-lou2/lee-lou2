---
title: 'JWTì™€ Cacheë¥¼ í™œìš©í•œ í† í° ì„œë¹„ìŠ¤'
authors: [jake]
tags: [python, fastapi, jwt, token, cache]
---

## â­ í‚¤ì›Œë“œ

| í‚¤ì›Œë“œ | ì„¤ëª… |
| --- | --- |
| JWT | JSON ì›¹ í† í°ì€ ì„ íƒì  ì„œëª… ë° ì„ íƒì  ì•”í˜¸í™”ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ë¥¼ ë§Œë“¤ê¸° ìœ„í•œ ì¸í„°ë„· í‘œì¤€ìœ¼ë¡œ, í˜ì´ë¡œë“œëŠ” ëª‡ëª‡ í´ë ˆì„ í‘œëª…ì„ ì²˜ë¦¬í•˜ëŠ” JSONì„ ë³´ê´€í•˜ê³  ìˆë‹¤. í† í°ì€ ë¹„ê³µê°œ ì‹œí¬ë¦¿ í‚¤ ë˜ëŠ” ê³µê°œ/ë¹„ê³µê°œ í‚¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ì„œëª…ëœë‹¤ |

## ğŸ¥ ì˜ˆì‹œ

```python
from datetime import datetime, timedelta
from typing import Union

import jwt
from fastapi import HTTPException

from project.core import exceptions as ex
from project.conf.prod import settings
from ..schemas import TokenGenerationIn, CodeType, DefaultTokenResponse, TokenGenerationOut, \
    TokenDecodeOut
from project.core.caches import token_cache

class TokenManager:
    """
    í† í° ê´€ë¦¬
    """

    def __init__(
            self,
            token_data: TokenGenerationIn,
    ):
        self.token_data = token_data
        self.delta = None

    @staticmethod
    def _set_token_white_list(obj: dict):
        """
        í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ìƒì„±
        :param obj:
        :return:
        """
        # ì‚¬ìš©ì ì •ë³´ë¡œ í† í° ì¡°íšŒ
        token_cache.rpush(obj.get('user_id'), obj.get('token'))
        for _ in range(token_cache.llen(obj.get('user_id')) - 2):
            token_cache.delete(token_cache.lpop(obj.get('user_id')))
        # ì‹ ê·œ í† í° ì¶”ê°€
        token_cache.set(obj.get('token'), '', obj.get('exp'))
        return True

    @staticmethod
    def _token_decode_valid(token: str):
        """
        í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ í™•ì¸
        :param token:
        :return:
        """
        # í† í° ì¡´ì¬ ì—¬ë¶€ í™•ì¸
        return token_cache.exists(token)

    def _token_generation(
            self,
            code_type: Union[str, CodeType]
    ) -> TokenGenerationOut:
        """
        í† í° ìƒì„±
        :return:
        """
        if self.delta is None:
            raise ex.AuthExceptions.ExpiredToken
        # í† í° ìœ íš¨ ì‹œê°„ ì§€ì •
        delta = self.delta or settings.ACCESS_TOKEN_EXPIRE_MINUTES
        # ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜
        to_encode = self.token_data.dict()
        # ìœ íš¨ ì‹œê°„ ì„¤ì •
        to_encode.update({'code_type': code_type})
        to_encode.update({'iat': datetime.utcnow()})
        to_encode.update({'exp': datetime.utcnow() + timedelta(minutes=delta)})

        # ì‹œí¬ë¦¿í‚¤ ì ìš©
        secret_key = \
            code_type == CodeType.A and settings.TOKEN_SECRET_KEY or settings.REFRESH_TOKEN_SECRET_KEY

        # í† í° ìƒì„±
        encoded_jwt = jwt.encode(
            to_encode,
            secret_key,
            algorithm=settings.ALGORITHM
        )
        # í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ì €ì¥
        white_list_data = {
            'user_id': to_encode.get('user_id'),
            'token': encoded_jwt,
            'exp': timedelta(minutes=delta),
            'code_type': code_type
        }
        if not self._set_token_white_list(white_list_data):
            raise Exception('í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ìƒì„± ì‹¤íŒ¨')
        res_token = {
            'token': encoded_jwt,
            'iat': to_encode.get('iat'),
            'exp': to_encode.get('exp')
        }
        return TokenGenerationOut(**res_token)

    def _get_token(
            self,
            code_type: Union[str, CodeType] = CodeType.A,
            delta: int = None
    ) -> TokenGenerationOut:
        """
        ê¸°ë³¸ í† í° ìƒì„±
        :param code_type:
        :param delta:
        :return:
        """
        # í† í° íƒ€ì… í™•ì¸
        if code_type == CodeType.R and delta is None:
            delta = settings.REFRESH_TOKEN_EXPIRE_MINUTES
        self.delta = delta or settings.ACCESS_TOKEN_EXPIRE_MINUTES
        return self._token_generation(code_type)

    def get_default_token(self) -> DefaultTokenResponse:
        """
        ì•¡ì„¸ìŠ¤, ë¦¬í”„ë ˆì‹œ í† í° ì¼ê´„ ìƒì„±
        :return:
        """
        tokens = {
            'access_token': self._get_token(CodeType.A),
            'refresh_token': self._get_token(CodeType.R)
        }
        return DefaultTokenResponse(**tokens)

    @staticmethod
    def decode_client_keys(
            key: str
    ) -> list:
        """
        í´ë¼ì´ì–¸íŠ¸ í‚¤ í•´ë…
        :param key:
        :return:
        """
        import base64
        encode_key = key.encode('utf-8')
        bs64_decode = base64.b64decode(encode_key)
        decode_key = bs64_decode.decode('utf-8')
        return decode_key.split(':')

    @staticmethod
    def decode_token(
            token: str,
            code_type: Union[str, CodeType] = CodeType.A
    ) -> TokenDecodeOut:
        try:
            # í† í° ìœ íš¨ì„± ê²€ì‚¬
            if not TokenManager._token_decode_valid(token):
                raise Exception('ìœ íš¨í•˜ì§€ ì•Šì€ í† í°ì…ë‹ˆë‹¤')

            # ì‹œí¬ë¦¿í‚¤ ì ìš©
            secret_key = \
                code_type == CodeType.A and settings.TOKEN_SECRET_KEY or settings.REFRESH_TOKEN_SECRET_KEY

            # í† í° ë³µí˜¸í™”
            payload = jwt.decode(
                token,
                secret_key,
                algorithms=[settings.ALGORITHM]
            )
            return TokenDecodeOut(**payload)
        except jwt.exceptions.ExpiredSignatureError as jwt_ex:
            # í† í° ìœ íš¨ê¸°ê°„ ì´ˆê³¼
            raise HTTPException(status_code=400, detail=str(jwt_ex))
        except jwt.exceptions.DecodeError as jwt_ex:
            # ìœ íš¨í•˜ì§€ ì•Šì€ í† í°
            raise HTTPException(status_code=400, detail=str(jwt_ex))
        except jwt.exceptions.InvalidTokenError as jwt_ex:
            # ê¸°íƒ€ ì˜¤ë¥˜
            raise HTTPException(status_code=400, detail=str(jwt_ex))
        except Exception as jwt_ex:
            # ìµœì¢… ì˜¤ë¥˜
            raise HTTPException(status_code=400, detail=str(jwt_ex))
```